<!DOCTYPE html>
<html lang="en">
<head>
	
	<meta charset="utf-8">
	<meta name="viewport" content="initial-scale=1, width=device-width">
	<meta content="IE=edge" http-equiv="X-UA-Compatible">
	
	<title>Fractals</title>
	
	<meta name="keywords" content="mandelbrot,julia,fractals">
	<meta name="description" content="A quick web-based javascript viewer for both the Mandelbrot and Julia sets">
	

</head>
<body>
	<canvas id="viewer" width="800" height="800" style="border:#eee;
  image-rendering: -moz-crisp-edges;
  image-rendering: -webkit-crisp-edges;
  image-rendering: pixelated;
  image-rendering: crisp-edges;"></canvas><br>

  	<progress id="progress" value="0" min="0" max="100"></progress>
	<label for="progress" id="progresslabel"></label>
	<br>
	

  	<progress id="subprogress" value="0" min="0" max="100"></progress>
	<label for="subprogress" id="subprogresslabel">
	</label>
	<br>
	
	<button onclick="draw()">Draw</button>
  <script src="qfm.js?refresh=4328489023"></script>
  <script src="fv.js?refresh=483204894"></script>
  
  <script>
	  var testing = false;
	  var canceller = {cancel:false};
	  var maxIterations = 500;
	  var lookupTable;
	  		// xi, xf, yi, yf
	  var viewbox = [-2,1,-1.5,1.5];
	  window.onload = async function () {
		  lookupTable = await fv.genLookupTable(800,800,function (subprogressNum,subprogressTotal,progressNum,progressTotal) {
			subprogress.value = Math.ceil((subprogressNum / subprogressTotal) * 100);
			subprogresslabel.innerText = `${subprogressNum} of ${subprogressTotal} Iterations complete`
			
			progress.value = Math.ceil((progressNum / progressTotal) * 100);
			progresslabel.innerText = `${progressNum} of ${progressTotal} Rounds complete`
		});
	  }
		const canvas = document.getElementById("viewer");
	  	const progress = document.getElementById("progress");
	  	const subprogress = document.getElementById("subprogress");
	  	const progresslabel = document.getElementById("progresslabel");
	  	const subprogresslabel = document.getElementById("subprogresslabel");
	  
	  	const ctx = canvas.getContext('2d', { alpha: false });
	  
	  	lookupFunc = (x,y) => {
			const xi = fv.map(x,0,800,viewbox[0],viewbox[1]);
			const yi = fv.map(y,0,800,viewbox[2],viewbox[3]);
			
			const i = qfm.mandelbrot(xi,yi,maxIterations);
			
			if (i === maxIterations) { return "#000000"; }
  			return "hsl(0,100%,"+(i%100)+"%)";
		}
		
		async function draw () {
			canceller.cancel = true;
			await fv._wait();
			canceller.cancel = false;
			await fv.draw(lookupFunc,lookupTable,ctx,canceller);
		}
	  
	  	function avg (a,b) {
			const two = (a + a) / (a);
			return (a + b) / two;
		}
	  	// TODO make func for convert to complex coords 
	  	
	  	canvas.onwheel = async (e) => {
			
			const mouseX = e.offsetX;
			const mouseY = e.offsetY;
			
			const currSpan = viewbox[1] - viewbox[0];
			
			// convert to either -1 or 1
			const scrollDelta = Math.min(Math.max(e.deltaY,-1),1);
			const scrollDeltaScaled = (1 + (scrollDelta * .2))
			
			// target coordinates should still be where it is currently
			const targetX = fv.map(mouseX,0,800,viewbox[0],viewbox[1]);
			const targetY = fv.map(mouseY,0,800,viewbox[2],viewbox[3]);
			

			
			const currCenterX = avg(viewbox[0],viewbox[1]);
			const currCenterY = avg(viewbox[2],viewbox[3]);
			
			
			
			const targetSpan = currSpan * scrollDeltaScaled;
			const targetHalfSpan = targetSpan / 2;
			
			const partialZoomedViewbox = [
				currCenterX-targetHalfSpan,
				currCenterX+targetHalfSpan,
				currCenterY-targetHalfSpan,
				currCenterY+targetHalfSpan,
			]
			
			const mouseXAfterZoom = fv.map(mouseX,0,800,partialZoomedViewbox[0],partialZoomedViewbox[1]);
			const mouseYAfterZoom = fv.map(mouseY,0,800,partialZoomedViewbox[2],partialZoomedViewbox[3]);
			
			const newCenterX = currCenterX + (targetX - mouseXAfterZoom);
			const newCenterY = currCenterY + (targetY - mouseYAfterZoom);
			
			
			viewbox = [
				newCenterX-targetHalfSpan,
				newCenterX+targetHalfSpan,
				newCenterY-targetHalfSpan,
				newCenterY+targetHalfSpan,
			];
			
			
			draw();
			
			
		}
		
		
	  
		
	
  </script>
</body>
</html>
